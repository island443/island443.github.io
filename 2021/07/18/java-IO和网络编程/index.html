<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.I&#x2F;O流">
<meta property="og:type" content="article">
<meta property="og:title" content="java IO和网络编程">
<meta property="og:url" content="http://example.com/2021/07/18/java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="island443">
<meta property="og:description" content="1.I&#x2F;O流">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/07/20/4hgWI2Yqp9vQSVE.png">
<meta property="og:image" content="https://i.loli.net/2021/07/20/RU5KHEFYfsWPGLi.jpg">
<meta property="og:image" content="https://i.loli.net/2021/07/20/rkXqplFHPIJYuZo.png">
<meta property="og:image" content="https://i.loli.net/2021/07/20/H6lXeRNEfCxK1Os.png">
<meta property="og:image" content="https://i.loli.net/2021/07/20/x3pRrsStZmfUQH2.jpg">
<meta property="og:image" content="https://i.loli.net/2021/07/21/cZMUPQrhHjXBF4S.jpg">
<meta property="og:image" content="https://i.loli.net/2021/07/21/LxspWjP4QnXweMK.jpg">
<meta property="article:published_time" content="2021-07-18T10:08:17.000Z">
<meta property="article:modified_time" content="2023-07-17T08:03:41.963Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/07/20/4hgWI2Yqp9vQSVE.png">


<link rel="canonical" href="http://example.com/2021/07/18/java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/07/18/java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","path":"2021/07/18/java-IO和网络编程/","title":"java IO和网络编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java IO和网络编程 | island443</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">island443</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-I-O%E6%B5%81"><span class="nav-number">1.</span> <span class="nav-text">1.I&#x2F;O流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1I-O%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1.1I&#x2F;O流概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.1.0.0.1.</span> <span class="nav-text">1.字节流和字符流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.1.0.0.2.</span> <span class="nav-text">2.输入流和输出流</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="nav-number">1.1.0.0.3.</span> <span class="nav-text">3.节点流和处理流</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">1.2.</span> <span class="nav-text">1.2字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%97%E8%8A%82%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">1.字节流概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">2.字节流读写文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">3.文件的拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">4.字节流的缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">5.字节缓冲流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.3.</span> <span class="nav-text">1.3字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%97%E7%AC%A6%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">1.字符流概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E6%B5%81%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">2.字符流操作文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">3.转换流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4File%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.4File类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.File类的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">1.构造方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2.遍历目录下的文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.删除文件及目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5RandomAccessFile"><span class="nav-number">1.4.</span> <span class="nav-text">1.5RandomAccessFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.5.</span> <span class="nav-text">1.6对象序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7NIO"><span class="nav-number">1.6.</span> <span class="nav-text">1.7NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-NIO%E6%A6%82%E8%BF%B0"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">1.NIO概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Buffer%EF%BC%88%E7%BC%93%E5%86%B2%E5%99%A8%EF%BC%89"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">2.Buffer（缓冲器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">3.Channel（通道）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8NIO-2"><span class="nav-number">1.7.</span> <span class="nav-text">1.8NIO.2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Path%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">1.Path接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Files%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">2.Files工具类</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/image%5Cavatar.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">非志无以成学</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/island443" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;island443" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2301062786@qq.com" title="E-Mail → mailto:2301062786@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/18/java-IO%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image%5Cavatar.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="island443">
      <meta itemprop="description" content="非志无以成学">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java IO和网络编程 | island443">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java IO和网络编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-18 18:08:17" itemprop="dateCreated datePublished" datetime="2021-07-18T18:08:17+08:00">2021-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-17 16:03:41" itemprop="dateModified" datetime="2023-07-17T16:03:41+08:00">2023-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-I-O流"><a href="#1-I-O流" class="headerlink" title="1.I&#x2F;O流"></a>1.I&#x2F;O流</h2><span id="more"></span>

<h3 id="1-1I-O流概述"><a href="#1-1I-O流概述" class="headerlink" title="1.1I&#x2F;O流概述"></a>1.1I&#x2F;O流概述</h3><p>I&#x2F;O流（Input&#x2F;Output）流，即输入输出流，是java中实现输入输出的基础，它可以方便地实现数据的输入输出操作。</p>
<p>I&#x2F;O流有很多种，按照不同的分类方式，可以分为以下三类：</p>
<h6 id="1-字节流和字符流"><a href="#1-字节流和字符流" class="headerlink" title="1.字节流和字符流"></a>1.字节流和字符流</h6><p>根据流操作的数据单位不同，可以分为字节流和字符流。字节流以字节为单位进行数据的读写，每次读写一个或者多个字节数据；字符流以字符为单位进行数据的读写，每次读写一个或者多个字符数据。</p>
<h6 id="2-输入流和输出流"><a href="#2-输入流和输出流" class="headerlink" title="2.输入流和输出流"></a>2.输入流和输出流</h6><p>根据流传输方向的不同，又可分为输入流和输出流。其中输入流只能从流中读取数据，而不能向其写入数据；输出流只能从流中写入数据，而不能从中读取数据。</p>
<h6 id="3-节点流和处理流"><a href="#3-节点流和处理流" class="headerlink" title="3.节点流和处理流"></a>3.节点流和处理流</h6><p>根据流的功能不同，可分为节点流和处理流。节点流也被称为低级流，是指可以从一个特定的I&#x2F;O设备（如磁盘）读写数据的流，它只能直接连接数据源，进行数据的读写操作；处理流也被称为高级流，它用于对一个已存在的节点流进行连接和封装，通过封装后的流来实现流的读写能力。当好使用处理流时，程序不会直接连接到实际的数据源，而是连接在已存在的流上。</p>
<p>Java的I&#x2F;O流主要定义在java.io包中，其中有四个类为流的顶级类，分别是InputStream,OutputStream,Reader,Writer</p>
<p><img src="https://i.loli.net/2021/07/20/4hgWI2Yqp9vQSVE.png" alt="顶层类.png"></p>
<p><strong>4个顶级类都是抽象类</strong>，并且是所有流类型的父亲</p>
<h3 id="1-2字节流"><a href="#1-2字节流" class="headerlink" title="1.2字节流"></a>1.2字节流</h3><h5 id="1-字节流概述"><a href="#1-字节流概述" class="headerlink" title="1.字节流概述"></a>1.字节流概述</h5><p>在计算机中，无论文本，视频，音频都是以二进制（字节）形式存在的，I&#x2F;O流中针对字节的输入输出提供了一系列的流，统称为字节流。所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream</p>
<p><img src="https://i.loli.net/2021/07/20/RU5KHEFYfsWPGLi.jpg" alt="输入输出流.jpeg"></p>
<p>InputStream可以被看出一个输入管道，OutputStream可以被看出一个输出管道，数据通过InputStream从源设备输入到程序，通过OutputStream从程序输出到目标设备，从而实现数据的传输。</p>
<p><strong>InputStream用于读数据，OutputStream用于写数据</strong></p>
<p>接下来了解一下InputStream的常用方法</p>
<ul>
<li>int read()   从输入流读取一个8位的字节，把它转换为0-255之间的整数，并返回这一整数。</li>
<li>int read(byte[] b) 从输入流读取若干字节，把它们保存到参数b指定的字节数组中，返回整数表示读取字节的数目</li>
<li>int read(byte[]b,int off,int len) 从输入流读取若干字节，把它们保存到参数b指定的字节数组中，off指定数组开始保存数据的起始下标，len表示读取的字节数目</li>
<li>void close() 关闭此输入流并释放与该流相关的所有系统资源</li>
</ul>
<p>接下来了解一下OutputStream的常用方法</p>
<ul>
<li>void write(int b) 向输出流写入一个数据</li>
<li>void write(byte[] b) 把参数b指定的字节数组的所有字节写到输出流</li>
<li>void write(byte[] b，int off,int len) 把参数b指定的字节数组的指定字节写到输出流</li>
<li>void flush() 刷新此输出流并强制写出所有缓冲的输出字节</li>
<li>void close() 关闭此输出流并释放与该流相关的所有系统资源</li>
</ul>
<p>flush()方法用来将当前输出流缓冲区（通常是字节数组）中的数据强制写到目标设备</p>
<p>在进行I&#x2F;O流操作时，当前I&#x2F;O流会占用一定内存，由于系统资源宝贵，因此I&#x2F;O操作结束后，应调用close()关闭流，从而释放资源</p>
<p>InputStream和OutputStream虽然提供了读写方法，但这两个类是抽象类，不能被实例化，因此针对不同的功能，InputStream和OutputStream提供了不同子类。</p>
<p><img src="https://i.loli.net/2021/07/20/rkXqplFHPIJYuZo.png" alt="VMR__YXNMJW_R__V_XGSHBU.png"></p>
<p><img src="https://i.loli.net/2021/07/20/H6lXeRNEfCxK1Os.png" alt="WY9_82_YU6EB_CWP_Z_32JF.png"></p>
<h5 id="2-字节流读写文件"><a href="#2-字节流读写文件" class="headerlink" title="2.字节流读写文件"></a>2.字节流读写文件</h5><p>针对文件的读写操作，JDK专门提供了两个类，分别是FileInputStram和FileOutputStream</p>
<p>下面通过一个案例实现字节流对文件数据的读取，首先在MyEclipse项目的根目录下，创建一个test.txt，在文件中输入内容“Hello“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Streamdemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//创建一个字节输入流来读取文件</span><br><span class="line">		FileInputStream in=new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">		</span><br><span class="line">		int b=0;</span><br><span class="line">		//通过循环来读取文件，当前值为-1结束循环</span><br><span class="line">		while((b=in.read())!=-1)&#123;</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//关闭流</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果（Hello对应的ASCII码值）</span><br><span class="line">72</span><br><span class="line">101</span><br><span class="line">108</span><br><span class="line">108</span><br><span class="line">111</span><br></pre></td></tr></table></figure>



<p>把数据写入文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Streamdemo2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		</span><br><span class="line">		//这种情况是先把文件内容情况在往里面写</span><br><span class="line">		FileOutputStream out=new FileOutputStream(&quot;test.txt&quot;);</span><br><span class="line">		</span><br><span class="line">		//这种情况是直接在文件后追加内容</span><br><span class="line">		//FileOutputStream out=new FileOutputStream(&quot;test.txt&quot;,true);</span><br><span class="line">		</span><br><span class="line">		String str=&quot;Hello&quot;;</span><br><span class="line">		//将字符串转换为字符数组进行写入操作</span><br><span class="line">		out.write(str.getBytes());</span><br><span class="line">		out.close();</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I&#x2F;O流在进行数据读写时会出现异常，为了代码简洁，上面使用了throws抛出。一旦遇到异常close()方法无法运行，所以要把close()方法放在finally代码块中。</p>
<h5 id="3-文件的拷贝"><a href="#3-文件的拷贝" class="headerlink" title="3.文件的拷贝"></a>3.文件的拷贝</h5><p>首先在当前项目文件夹下创建source和target文件夹，然后在source下放一个名称为”src.jpg”的图片，拷贝文件的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Streamdemo3 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileInputStream in=new FileInputStream(&quot;source/src.jpg&quot;);</span><br><span class="line">		FileOutputStream out=new FileOutputStream(&quot;target/dest.jpg&quot;);</span><br><span class="line">		</span><br><span class="line">		int len=0;</span><br><span class="line">		long beginTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		while((len=in.read())!=-1)&#123;</span><br><span class="line">			out.write(len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		long endTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;拷贝花费时间:&quot;+(endTime-beginTime)+&quot;毫秒&quot;);</span><br><span class="line">		</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//拷贝花费时间:20830毫秒</span><br></pre></td></tr></table></figure>



<h5 id="4-字节流的缓冲区"><a href="#4-字节流的缓冲区" class="headerlink" title="4.字节流的缓冲区"></a>4.字节流的缓冲区</h5><p>上节拷贝是一个字节一个字节的读写，需要频繁操作文件，效率非常低。</p>
<p>好比运输快递，从保定到定州，一件一件运，效率低，为了减少运输次数可以把一批快递装在一个车厢中，成批的运，这时车厢就相当于一个临时缓冲区。</p>
<p>同样，通过流操作拷贝文件时，可以定义一个字节数组作为缓冲区，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Streamdemo3 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileInputStream in=new FileInputStream(&quot;source/src.jpg&quot;);</span><br><span class="line">		FileOutputStream out=new FileOutputStream(&quot;target/dest.jpg&quot;);</span><br><span class="line">		</span><br><span class="line">		int len=0;</span><br><span class="line">		//定义一个长度为1024的字节数组</span><br><span class="line">		byte[] buff=new byte[1024]; </span><br><span class="line">		long beginTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		while((len=in.read(buff))!=-1)&#123;</span><br><span class="line">			out.write(buff,0,len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		long endTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;拷贝花费时间:&quot;+(endTime-beginTime)+&quot;毫秒&quot;);</span><br><span class="line">		</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//拷贝花费时间:30毫秒</span><br></pre></td></tr></table></figure>



<h5 id="5-字节缓冲流"><a href="#5-字节缓冲流" class="headerlink" title="5.字节缓冲流"></a>5.字节缓冲流</h5><p>在I&#x2F;O包中提供了两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutPutStream,它们的构造方法中分别能接受InputStream和OutputStream类型的参数作为对象，在读写操作时提供缓冲功能。</p>
<p><strong>为什么构造方法用字节流，而不是文件或路径呢？</strong><br>字节缓冲流：提供的是缓冲区，读写数据还得靠字节流对象。</p>
<p><img src="https://i.loli.net/2021/07/20/x3pRrsStZmfUQH2.jpg" alt="缓冲流.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Streamdemo4 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		BufferedInputStream bis=new BufferedInputStream(new FileInputStream(&quot;source/src.jpg&quot;));</span><br><span class="line">		BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(&quot;target/dest332.jpg&quot;));</span><br><span class="line">		</span><br><span class="line">		int len=0;</span><br><span class="line">		long beginTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		while((len=bis.read())!=-1)&#123;</span><br><span class="line">			bos.write(len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		long endTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;拷贝花费时间:&quot;+(endTime-beginTime)+&quot;毫秒&quot;);</span><br><span class="line">		</span><br><span class="line">		bis.close();</span><br><span class="line">		bos.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//拷贝花费时间:73毫秒</span><br></pre></td></tr></table></figure>





<h3 id="1-3字符流"><a href="#1-3字符流" class="headerlink" title="1.3字符流"></a>1.3字符流</h3><h5 id="1-字符流概述"><a href="#1-字符流概述" class="headerlink" title="1.字符流概述"></a>1.字符流概述</h5><p>InputStream和OutputStream类读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便了，为此JDK提供了用于实现字符操作的字符流。</p>
<p>字符流也有两个抽象的顶级父类，分别是Reader（字符输入流）和Writer（字符输出流）。</p>
<p>这是一些常用子类：</p>
<p><img src="https://i.loli.net/2021/07/21/cZMUPQrhHjXBF4S.jpg" alt="W.jpg"></p>
<p><img src="https://i.loli.net/2021/07/21/LxspWjP4QnXweMK.jpg" alt="R.jpg"></p>
<p>其中FileReader和FileWriter用于读写文件，BufferedReader和BufferedWriter是具有缓冲功能的流，使用它们可以提高效率。</p>
<h5 id="2-字符流操作文件"><a href="#2-字符流操作文件" class="headerlink" title="2.字符流操作文件"></a>2.字符流操作文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Readerdemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileReader fileReader=new FileReader(&quot;test.txt&quot;);</span><br><span class="line">		</span><br><span class="line">		int len=0;</span><br><span class="line">		while((len=fileReader.read())!=-1)&#123;</span><br><span class="line">			System.out.print((char)len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fileReader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileWriter fileWriter=new FileWriter(&quot;test.txt&quot;);</span><br><span class="line">		fileWriter.write(&quot;轻轻地我走了,\r\n&quot;);</span><br><span class="line">		fileWriter.write(&quot;正如我轻轻地来,\r\n&quot;);</span><br><span class="line">		fileWriter.write(&quot;我轻轻地挥手,\r\n&quot;);</span><br><span class="line">		fileWriter.write(&quot;作别西天的云彩,\r\n&quot;);</span><br><span class="line"></span><br><span class="line">		fileWriter.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWriter和FileOutputStream一样，如果指定的文件不存在，就会先创建文件，再写入数据；如果文件存在，则会首先清空文件中的内容，在进行写入。如果想在文件末尾追加信息，需使用重载的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fileWriter=new FileWriter(&quot;test.txt&quot;,true);</span><br></pre></td></tr></table></figure>



<p>上面两个案例是逐个字符进行读写，频繁的操作文件，效率低。</p>
<p>下面是使用缓冲区实现文件的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ReaderDemo2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileReader fileReader=new FileReader(&quot;test.txt&quot;);</span><br><span class="line">		FileWriter fileWriter=new FileWriter(&quot;writer.txt&quot;);</span><br><span class="line">		int len=0;</span><br><span class="line">		</span><br><span class="line">		//这里是创建了一个字符缓冲区</span><br><span class="line">		char[] buff=new char[1024];</span><br><span class="line">		</span><br><span class="line">		while((len=fileReader.read(buff))!=-1)&#123;</span><br><span class="line">			fileWriter.write(buff,0,len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fileReader.close();</span><br><span class="line">		fileWriter.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用缓冲流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ReaderDemo2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		</span><br><span class="line">		BufferedReader br=new BufferedReader(new FileReader(&quot;test.txt&quot;));</span><br><span class="line">		BufferedWriter bw=new BufferedWriter(new FileWriter(&quot;writer.txt&quot;));				</span><br><span class="line">		</span><br><span class="line">		String str=null;</span><br><span class="line"></span><br><span class="line">		//readLine()该方法用于一次读取一行文本</span><br><span class="line">		while((str=br.readLine())!=null)&#123;</span><br><span class="line">			bw.write(str);</span><br><span class="line">			//写入一个换行符</span><br><span class="line">			bw.newLine();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3.转换流"></a>3.转换流</h5><p>有时字节流和字符流之间也需要进行转换，在JDK中提供了两个类用于实现将字节流转换为字符流，分别是InputStreamReader和OutputStreamWriter。</p>
<p>下面通过一个案例来学习如何将字节流转换为字符流，为了提高效率，可以通过BufferedReader和BufferedWriter来实现转换工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class zhuanhuan &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		FileInputStream in=new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">		//将字节输入流对象转换为字符输入流对象</span><br><span class="line">		InputStreamReader isr=new InputStreamReader(in);</span><br><span class="line">		</span><br><span class="line">		BufferedReader br=new BufferedReader(isr);</span><br><span class="line">		</span><br><span class="line">		FileOutputStream out=new FileOutputStream(&quot;writer.txt&quot;);</span><br><span class="line">		//将字节输出流对象转换为字符输出流</span><br><span class="line">		OutputStreamWriter osw=new OutputStreamWriter(out);</span><br><span class="line">		BufferedWriter bw=new BufferedWriter(osw);</span><br><span class="line">		</span><br><span class="line">		String line=null;</span><br><span class="line">		</span><br><span class="line">		while((line=br.readLine())!=null)&#123;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在使用转换流时，只能针对操作文本文件的字节流进行转换，如果字节流操作的是字节码内容的文件（如图片，视频等），此时转换为字符流就会造成数据损失。</p>
<h4 id="1-4File类"><a href="#1-4File类" class="headerlink" title="1.4File类"></a>1.4File类</h4><p>针对文件本身的操作例如创建文件，删除或重命名文件，无法通过I&#x2F;O流完成，针对文件这类操作，JDK中提供了一个File，该类封装了一个路径，并提供了一系列的方法用于操作该路径所指向的文件。</p>
<h5 id="1-File类的常用方法"><a href="#1-File类的常用方法" class="headerlink" title="1.File类的常用方法"></a>1.File类的常用方法</h5><h6 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h6><ul>
<li>File(String pathname)：根据一个路径得到File对象</li>
<li>File(String parent, String child):根据一个目录和一个子文件&#x2F;目录得到File对象</li>
<li>File(File parent, String child):根据一个父File对象和一个子文件&#x2F;目录得到File对象</li>
</ul>
<p>首先，在项目当前目录下创建一个文件”example.txt”,并在文件中输入内容“File”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Filedemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建File文件对象</span><br><span class="line">		File file=new File(&quot;example.txt&quot;);</span><br><span class="line">		System.out.println(&quot;文件名称:&quot;+file.getName());</span><br><span class="line">		System.out.println(&quot;文件的相对路径:&quot;+file.getPath());</span><br><span class="line">		System.out.println(&quot;文件的绝对路径:&quot;+file.getAbsolutePath());</span><br><span class="line">		System.out.println(&quot;文件的父路径:&quot;+file.getParent());</span><br><span class="line">		System.out.println(file.canRead()?&quot;文件可读&quot;:&quot;文件不可读&quot;);</span><br><span class="line">		System.out.println(file.canWrite()?&quot;文件可写&quot;:&quot;文件不可写&quot;);</span><br><span class="line">		System.out.println(file.isFile()?&quot;是一个文件&quot;:&quot;不是一个文件&quot;);</span><br><span class="line">		System.out.println(file.isDirectory()?&quot;是一个目录&quot;:&quot;不是一个目录&quot;);</span><br><span class="line">		System.out.println(file.isAbsolute()?&quot;是绝对路径&quot;:&quot;不是绝对路径&quot;);</span><br><span class="line">		System.out.println(&quot;最后修改时间:&quot;+file.lastModified());</span><br><span class="line">		System.out.println(&quot;文件大小为:&quot;+file.length()+&quot;bytes&quot;);</span><br><span class="line">		System.out.println(&quot;是否成功删除文件:&quot;+file.delete());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-遍历目录下的文件"><a href="#2-遍历目录下的文件" class="headerlink" title="2.遍历目录下的文件"></a>2.遍历目录下的文件</h5><p>File类中有一个list（）方法，该方法用于遍历某个指定目录下的所有文件的名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Filedemo2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File file=new File(&quot;E:\\Blog&quot;);</span><br><span class="line">		if(file.isDirectory())&#123;</span><br><span class="line">			String[] fileNames=file.list();</span><br><span class="line">			Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在上一个案例基础上来演示如何筛选遍历指定该目录下所有拓展名为”.txt“的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Filedemo2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File file=new File(&quot;E:\\Blog&quot;);</span><br><span class="line">		if(file.isDirectory())&#123;</span><br><span class="line">			String[] fileNames=file.list((dir,name)-&gt;name.endsWith(&quot;.txt&quot;));</span><br><span class="line">			Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来通过一个案例来实现遍历指定目录下的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Filedemo3 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File file=new File(&quot;E:\\Blog&quot;);		</span><br><span class="line">		fileDir(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void fileDir(File file) &#123;</span><br><span class="line">		File[] listFiles=file.listFiles();</span><br><span class="line">		for(File files:listFiles)&#123;</span><br><span class="line">			if(files.isDirectory())&#123;</span><br><span class="line">				fileDir(files);</span><br><span class="line">			&#125;			</span><br><span class="line">			System.out.println(files);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-删除文件及目录"><a href="#3-删除文件及目录" class="headerlink" title="3.删除文件及目录"></a>3.删除文件及目录</h5><p>接下来通过一个案例讲解如何使用delete()方法删除指定目录下的文件和文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Filedemo4 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File files=new File(&quot;E:\\test\\新建文件夹&quot;);</span><br><span class="line">		deleteDir(files);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void deleteDir(File files) &#123;</span><br><span class="line">		File[] listFiles=files.listFiles();</span><br><span class="line">		for(File file:listFiles)&#123;</span><br><span class="line">			//如果是目录文件，则递归调用删除方法</span><br><span class="line">			if(files.isDirectory())&#123;</span><br><span class="line">				deleteDir(file);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			//如果是文件，则删除</span><br><span class="line">			file.delete();			</span><br><span class="line">		&#125;</span><br><span class="line">		//删除文件夹内文件后，再删除文件夹</span><br><span class="line">		files.delete();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5RandomAccessFile"><a href="#1-5RandomAccessFile" class="headerlink" title="1.5RandomAccessFile"></a>1.5RandomAccessFile</h3><p>前面介绍的I&#x2F;O流有一个共同特点，就是只能按照数据的先后顺序读取源设备中的数据，或者按照数据的先后顺序向目标设备写入数据，但如果希望从文件的任意位置开始执行读写命令操作，则字符流和字节流都无法实现，为此在I&#x2F;O包中提供了一个RandomAccessFile类，他不属于流类，但是有读写文件数据的功能，<strong>可以随机从文件的任何位置开始执行读写数据的操作。</strong></p>
<p>RandomAccessFile可以将文件以指定的操作权限（如只读，可读写）的方式打开，具体使用哪种权限取决于创建它所采用的构造方法。</p>
<p>RandomAccessFile对象包含了一个记录指针来标识当前读写的位置，当新建RandomAccessFile对象时，该对象的文件巨鹿指针会在文件开始出（即0），当读写n个字节，文件记录指针会向后移动n个位置。RandomAccessFile对象的seek（long pos）方法可以自由的移动指针。</p>
<p>下面案例模仿付费软件的试用次数，首先在项目文件下新建一个time.txt文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class RandomAccessFiledemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//创建RandomAccessFile对象，并以读写模式打开time.txt文件</span><br><span class="line">		RandomAccessFile raf=new RandomAccessFile(&quot;time.txt&quot;,&quot;rw&quot;);</span><br><span class="line">		//读取还可以使用次数，第一次读取times为5</span><br><span class="line">		int times=Integer.parseInt(raf.readLine())-1;</span><br><span class="line">		//判断剩余次数</span><br><span class="line">		if(times&gt;0)&#123;</span><br><span class="line">			System.out.println(&quot;您还可以免费使用:&quot;+times+&quot;次&quot;);</span><br><span class="line">			//将记录指针重新指向文件开头</span><br><span class="line">			raf.seek(0);</span><br><span class="line">			raf.write((times+&quot;&quot;).getBytes());		</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;次数用完！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		raf.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6对象序列化"><a href="#1-6对象序列化" class="headerlink" title="1.6对象序列化"></a>1.6对象序列化</h3><p>对象的序列化（Serializable）是指将一个Java对象转换成一个I&#x2F;O流中字节序列的过程。其目的是为了将对象保存到磁盘中，或允许在网络中直接传输对象。</p>
<p>对象序列化机制可以使内存中的Java对象转换为与平台无关的二进制流，既可以将这种二进制流持久地保存在磁盘上，又可以通过网络传输到另一个网络节点，其他程序在获得了这种二进制流后，还可以把它恢复为原来的Java对象，这种将I&#x2F;O流中的字节序列恢复为java对象的过程称之为反序列化（Deserialize）。</p>
<p>如果想让某个对象支持序列化机制，那么这个对象所在的类必须是可序列化的。在java中可序列化的类必须实现Serializable或Externalizable两个接口之一。</p>
<p>与实现Serializable接口相比，虽然实现Externalizable接口可以带来一定性能上的提升，但也导致编程的复杂度增加。实际开发中，大部分都是采用Serializable接口的方式来实现序列化。</p>
<p>例如让Person类实现序列化接口的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">	//为该类指定一个serialVersionUID变量值</span><br><span class="line">	private static final long serialVersionUID=1L;</span><br><span class="line">	</span><br><span class="line">	private int id;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	//此处省略getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>serialVersionUID变量值的作用是标识java类的序列化版本，如果不是显示的定义serialVersionUID变量值，那么又JVM根据类的相关信息计算出一个serialVersionUID变量值。</p>
<h3 id="1-7NIO"><a href="#1-7NIO" class="headerlink" title="1.7NIO"></a>1.7NIO</h3><p>从JDK1.4开始，java提供一系列改进的用于处理输入输出的新功能，这些新功能被称之为NIO（New I&#x2F;O）</p>
<h5 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h5><p>NIO是为替代传统标准的I&#x2F;O而出现的。NIO提供了一种与I&#x2F;O不同的工作方式，NIO采用内存映射文件的方式来处理输入输出，它将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。</p>
<p>标准I&#x2F;O，使用的是字节流和字符流，<strong>而在NIO中，使用的是通道（Channel）和缓冲区。数据总是从通道进入缓冲区，或从缓冲区写入通道</strong>。</p>
<p>NIO主要有三大核心部分：Buffer,Channel和Selector。</p>
<ul>
<li>Buffer可以被看成一个容器，其本质是一个数组缓冲区，读入或写出到Channel中的所有对象都会先放在Buffer中。</li>
<li>Channel是对传统的输入输出的模拟，在NIO中，所有的数据都需要通过通道流的形式传输。</li>
<li>Selector（选择器）用于监听多个通道的事件（例如：链接打开，数据到达等），主要用于多线程处理。</li>
</ul>
<h5 id="2-Buffer（缓冲器）"><a href="#2-Buffer（缓冲器）" class="headerlink" title="2.Buffer（缓冲器）"></a>2.Buffer（缓冲器）</h5><p>Java NIO中的Buffer用于和NIO中的Channel进行交互，交互时数据会从Channel读取到Buffer中，或从Buffer写入到Channel中。</p>
<p>从结构上说，Buffer类似与一个数组，他可以保存多个类型相同的数据，从类型上说，Buffer是一个抽象类，其子类有ByteBuffer,CharBuffer,DoubleBuffer等</p>
<p>Buffer类的子类中并没有提供构造方法，因此<strong>不能通过构造方法来创建对象</strong>，而是通过子类中的</p>
<p>static XxxBuffer allocate(int capacity)方法实现，此方法含义是创建一个容量为capacity的XxxBuffer对象。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个容量为6的CharBuffer对象</span><br><span class="line">CharBuffer buffer=CharBuffer.allocate(6);</span><br></pre></td></tr></table></figure>



<p>Buffer中的三个重要概念：</p>
<ul>
<li>capacity（容量）：缓冲区的容量表示该Buffer的最大数据容量，即最多可以存储多少数据，缓冲区容量不能为负数，也不能够改变。</li>
<li>limit（界限）：表示Buffer容器中不可被读取的区域的第一个索引，即位于Buffer容器中索引为0到limit之间的区域都可以进行读取操作。缓冲区的limit值不为负，也不大于其容量。</li>
<li>position（位置）：用于指定下一个可以被读写的缓冲区位置索引，新创建的Buffer对象，position的默认值为0，每进行一次读取或写入操作，position的值都会自动向后移动一步。如果向Buffer缓冲区中执行8次写入操作，那么position的值为8，即指向Buffer中的第九个元素的索引位置。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>Buffer clear()	清除缓冲区，将position设为0，limit设为capacity</li>
<li>Buffer flip()       反转缓冲区，先将limit设置为当前position值，然后再将position设置为0</li>
</ul>
<p>下面通过一个具体案例来演示Buffer的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class Bufferdemo1 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建CharBuffer对象，并指定缓冲区的容量大小为6</span><br><span class="line">		CharBuffer charBuffer=CharBuffer.allocate(6);</span><br><span class="line">		System.out.println(&quot;容量:&quot;+charBuffer.capacity());</span><br><span class="line">		System.out.println(&quot;界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;初始位置:&quot;+charBuffer.position());</span><br><span class="line">		//向对象中放入3个元素</span><br><span class="line">		charBuffer.put(&#x27;x&#x27;);</span><br><span class="line">		charBuffer.put(&#x27;y&#x27;);</span><br><span class="line">		charBuffer.put(&#x27;z&#x27;);</span><br><span class="line">		System.out.println(&quot;加入元素后的界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;加入元素后的位置:&quot;+charBuffer.position());</span><br><span class="line">		</span><br><span class="line">		//执行flip（）方法</span><br><span class="line">		charBuffer.flip();</span><br><span class="line">		System.out.println(&quot;执行flip（）方法后的界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;执行flip（）方法后的位置:&quot;+charBuffer.position());</span><br><span class="line">		</span><br><span class="line">		//取出第一个元素</span><br><span class="line">		System.out.println(&quot;取出的第一个元素值为:&quot;+charBuffer.get());</span><br><span class="line">		System.out.println(&quot;取出后的界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;取出后的位置:&quot;+charBuffer.position());</span><br><span class="line">		</span><br><span class="line">		//执行clear（）方法</span><br><span class="line">		charBuffer.clear();</span><br><span class="line">		System.out.println(&quot;执行clear（）方法后的界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;执行clear（）方法后的位置:&quot;+charBuffer.position());</span><br><span class="line">		</span><br><span class="line">		//取出第一个元素</span><br><span class="line">		System.out.println(&quot;取出的第一个元素值为:&quot;+charBuffer.get(0));</span><br><span class="line">		System.out.println(&quot;取出后的界限值:&quot;+charBuffer.limit());</span><br><span class="line">		System.out.println(&quot;取出后的位置:&quot;+charBuffer.position());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果</span><br><span class="line">容量:6</span><br><span class="line">界限值:6</span><br><span class="line">初始位置:0</span><br><span class="line">加入元素后的界限值:6</span><br><span class="line">加入元素后的位置:3</span><br><span class="line">执行flip（）方法后的界限值:3</span><br><span class="line">执行flip（）方法后的位置:0</span><br><span class="line">取出的第一个元素值为:x</span><br><span class="line">取出后的界限值:3</span><br><span class="line">取出后的位置:1</span><br><span class="line">执行clear（）方法后的界限值:6</span><br><span class="line">执行clear（）方法后的位置:0</span><br><span class="line">取出的第一个元素值为:x</span><br><span class="line">取出后的界限值:6</span><br><span class="line">取出后的位置:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3-Channel（通道）"><a href="#3-Channel（通道）" class="headerlink" title="3.Channel（通道）"></a>3.Channel（通道）</h5><p><strong>Channel是一个接口对象</strong>，他类似于传统的流对象，但与传统的流对象又有些不同，其具体表现如下：</p>
<ul>
<li>Channel可以异步地执行I&#x2F;O读写操作</li>
<li>Channel的读写操作是双向的，既可以从Channel中读取数据，又可以写数据到Channel，而流的读写操作通常都是单向的</li>
<li>Channel可以直接将指定文件的部分或全部直接映射为Buffer</li>
<li><strong>Channel只能与Buffer进行交互，程序不能直接读写Channel中的数据</strong></li>
</ul>
<p>要使用Channel，就需要使用它的实现类，在java.nio.channels包中，提供了很多Channel接口的实现类，包括DatagramChannel（支持UDP网络通信），FileChannel（用于从文件中读写数据）Pipe,SinkChannel,Pipe.SourceChannel(这些支持线程间的通信)等</p>
<p>这里主要讲解FileChannel的使用</p>
<p>Channel不能通过构造方法来创建对象，而是通过传统I&#x2F;O的getChannel（）方法来获取对应的Channel。不同的流所获取的Channel是不同的，例如FileInputStream和FileOutputStream获取的是FileChannel；而PipedInputStream和PipedOutputStream所获取的是Pipe</p>
<p>下面通过一个文件拷贝的例子来学习FileChannel的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Channel &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	</span><br><span class="line">		//创建RandomAccessFile对象，指定源对象</span><br><span class="line">		RandomAccessFile infine=new RandomAccessFile(&quot;source/src.jpg&quot;,&quot;rw&quot;);</span><br><span class="line">		</span><br><span class="line">		//获取读取源文件FileChannel通道</span><br><span class="line">		FileChannel inChannel=infine.getChannel(); </span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//创建RandomAccessFile对象，指定目标文件</span><br><span class="line">		RandomAccessFile outfine=new RandomAccessFile(&quot;target/dest33.jpg&quot;,&quot;rw&quot;);</span><br><span class="line">				</span><br><span class="line">		//获取复制目标文件FileChannel通道</span><br><span class="line">		FileChannel outChannel=outfine.getChannel(); </span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//使用transferTo()方法进行整体复制</span><br><span class="line">		long transferTo=inChannel.transferTo(0,inChannel.size(),outChannel);</span><br><span class="line">		</span><br><span class="line">		if(transferTo&gt;0)&#123;</span><br><span class="line">			System.out.println(&quot;复制成功&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//关闭资源</span><br><span class="line">		infine.close();</span><br><span class="line">		inChannel.close();</span><br><span class="line">		outfine.close();</span><br><span class="line">		outChannel.close();</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RandomAccessFile类的构造方法生成两个RandomAccessFile对象，同时还指定了拷贝文件的源文件和目标文件名称以及可执行的操作，然后通过getChannel()方法获取对应的FileChannel类分别用于文件读取和写入通道。接下来通过FileChannel类的 transferTo(long position, long count, WritableByteChannel target)方法实现了整个文件的拷贝，该方法的第1个参数表示所需转移文件的起始位置，这里表示从0开始；第2个参数表示要传输的最大字节数，这里通过size()方法获取了文件的字节数；第3个参数表示目标通道，即要传输到的位置。最后文件拷贝完毕后，关闭资源。</p>
<h3 id="1-8NIO-2"><a href="#1-8NIO-2" class="headerlink" title="1.8NIO.2"></a>1.8NIO.2</h3><p>JDK7引入了新的I&#x2F;O API，对原有I&#x2F;O API中的功能进行改进，这个改进后的NIO就称之为NIO.2，其中最大的改进就是提供了全面的文件输入输出以及文件系统的访问与支持，并且新增了java.nio.file包，而且还提供了基于异步Channel的输入输出。</p>
<h5 id="1-Path接口"><a href="#1-Path接口" class="headerlink" title="1.Path接口"></a>1.Path接口</h5><p>前面学习的File虽然可以访问文件系统，但是File提供的方法性能较低，大多数方法出错时返回失败而不提供异常信息，而且File还不能利用特点的文件系统的特性。为了弥补这种不足，NIO.2提供了一个Path接口，该接口是一个用在文件系统中定位文件的对象，通常表示一个依赖于系统的文件路径。</p>
<p>除此之外NIO.2还提供了Paths和Files两个工具类，其中Paths类中提供了两个返回Path的静态方法，通过这两个方法可以创建Path对象，Files提供了大量静态方法来操作文件。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class pathdemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//使用Paths的get（）方法创建Path对象</span><br><span class="line">		Path path=Paths.get(&quot;E:\\Blog\\public\\index.html&quot;);</span><br><span class="line">		</span><br><span class="line">		//输出Path对象中的信息</span><br><span class="line">		System.out.println(&quot;path的根路径:&quot;+path.getRoot());</span><br><span class="line">		System.out.println(&quot;path的父路径:&quot;+path.getParent());</span><br><span class="line">		System.out.println(&quot;path中的路径名称数:&quot;+path.getNameCount());</span><br><span class="line">		</span><br><span class="line">		//循环输出路径</span><br><span class="line">		for(int i=0;i&lt;path.getNameCount();i++)&#123;</span><br><span class="line">			Path name=path.getName(i);</span><br><span class="line">			System.out.println(&quot;索引为&quot;+i+&quot;的路径的名称是:&quot;+name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;path的URI路径为:&quot;+path.toUri());</span><br><span class="line">		System.out.println(&quot;path的绝对路径为:&quot;+path.toAbsolutePath());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果</span><br><span class="line">path的根路径:E:\</span><br><span class="line">path的父路径:E:\Blog\public</span><br><span class="line">path中的路径名称数:3</span><br><span class="line">索引为0的路径的名称是:Blog</span><br><span class="line">索引为1的路径的名称是:public</span><br><span class="line">索引为2的路径的名称是:index.html</span><br><span class="line">path的URI路径为:file:///E:/Blog/public/index.html</span><br><span class="line">path的绝对路径为:E:\Blog\public\index.html</span><br></pre></td></tr></table></figure>



<h5 id="2-Files工具类"><a href="#2-Files工具类" class="headerlink" title="2.Files工具类"></a>2.Files工具类</h5><p>Files工具类是一个操作文件的工具类，包含了大量静态方法</p>
<p>通过一个具体的案例来演示Files类中一些常用方法的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Filesdemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//定义一个目录路径的Path对象</span><br><span class="line">		Path directoryPath=Paths.get(&quot;E:/javaEE1&quot;);</span><br><span class="line">		//根据Path对象创建多级目录</span><br><span class="line">		Files.createDirectories(directoryPath);</span><br><span class="line">		System.out.println(&quot;目录创建成功&quot;);</span><br><span class="line">		</span><br><span class="line">		//定义一个文件路径的Path对象</span><br><span class="line">		Path filePath=Paths.get(&quot;E:/javaEE/jQuery/test1.txt&quot;);</span><br><span class="line">		//根据Path对象创建一个文件</span><br><span class="line">		Files.createFile(filePath);</span><br><span class="line">		//创建一个List集合</span><br><span class="line">		List&lt;String&gt;list=new ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(&quot;这是一个测试文件&quot;);</span><br><span class="line">		//将集合中的内容追加写入到指定的文件中</span><br><span class="line">		Files.write(filePath,list,StandardOpenOption.APPEND);</span><br><span class="line">		List&lt;String&gt;lines=Files.readAllLines(filePath);</span><br><span class="line">		System.out.println(&quot;文件的大小为:&quot;+Files.size(filePath));</span><br><span class="line">		System.out.println(&quot;文件的内容为:&quot;+lines);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/12/NET%E8%B7%A8%E5%B9%B3%E5%8F%B0/" rel="prev" title="NET跨平台">
                  <i class="fa fa-chevron-left"></i> NET跨平台
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/10/python/" rel="next" title="python">
                  python <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81ODczNS8zNTE5Nw=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
